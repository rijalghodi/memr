import { generateKeyBetween } from "fractional-indexing";

/**
 * Generates the first rank (minimum rank)
 * @returns The first rank as a string
 */
export function generateFirstRank(): string {
  // Generate first key by passing null for both left and right
  return generateKeyBetween(null, null);
}

/**
 * Generates the last rank (maximum rank)
 * Note: This doesn't generate a true "last" rank since fractional indexing
 * has no maximum. Instead, it generates a rank that is very large and can
 * be used as a boundary marker. To ensure it's always greater than ranks
 * generated by generateBetweenRank(left, undefined), we generate it after
 * a rank that's already after the first rank.
 * @returns The last rank as a string
 */
export function generateLastRank(): string {
  // Generate a key after the first rank, then generate another key after that
  // This ensures the "last rank" is always greater than any single insertion
  const firstRank = generateFirstRank();
  const afterFirst = generateKeyBetween(firstRank, null);
  // Generate another rank after afterFirst to ensure it's always greater
  return generateKeyBetween(afterFirst, null);
}

/**
 * Generates a rank between two ranks
 * @param left - The left rank (or undefined to use first rank)
 * @param right - The right rank (or undefined to use last rank)
 * @returns A rank string between left and right
 */
export function generateBetweenRank(
  left: string | undefined,
  right: string | undefined,
): string {
  // Normalize undefined to null for fractional-indexing API
  const leftKey: string | null = left === undefined ? null : left || null;
  const rightKey: string | null = right === undefined ? null : right || null;

  // If both are null/undefined, generate first rank
  if (!leftKey && !rightKey) {
    return generateFirstRank();
  }

  // Special case: if inserting at beginning (left undefined)
  if (!leftKey && rightKey) {
    const firstRank = generateFirstRank();
    // If right is the first rank, generateKeyBetween(null, firstRank) returns "Zz"
    // which is lexicographically less than "a0". For our use case, we want to
    // insert at the beginning, so we use the result from generateKeyBetween.
    try {
      const rank = generateKeyBetween(null, rightKey);
      // If the generated rank is less than first rank, that's okay - it's a valid
      // rank that comes before rightKey
      return rank;
    } catch {
      // If generation fails, return first rank as fallback
      return firstRank;
    }
  }

  // Special case: if inserting at end (right undefined) and left is last rank or greater,
  // generate a new rank after left
  if (leftKey && !rightKey) {
    try {
      return generateKeyBetween(leftKey, null);
    } catch {
      // If left is invalid, fall back to first rank
      return generateFirstRank();
    }
  }

  // Try to generate the key, handling validation and order issues
  try {
    // Check if left and right are in correct order
    // Fractional-indexing keys can be compared lexicographically
    if (leftKey && rightKey && leftKey.localeCompare(rightKey) > 0) {
      // Swap if not in correct order
      return generateKeyBetween(rightKey, leftKey);
    }

    // Generate rank between left and right
    // generateKeyBetween handles null values:
    // - null, null = first rank (handled above)
    // - null, key = key before 'key' (may be less than first rank)
    // - key, null = key after 'key' (insert at end)
    return generateKeyBetween(leftKey, rightKey);
  } catch {
    // Handle errors from fractional-indexing library
    // This can happen if keys are invalid or too close together

    // If left is invalid or causes error, try with null (beginning)
    if (leftKey) {
      try {
        // Try inserting at beginning (before right)
        if (rightKey) {
          const firstRank = generateFirstRank();
          // If right is first rank, return first rank
          if (rightKey === firstRank) {
            return firstRank;
          }
          // Otherwise try to generate before right
          return generateKeyBetween(null, rightKey);
        }
      } catch {
        // If right is also invalid, fall back to first rank
        if (!rightKey) {
          return generateFirstRank();
        }
        // Final fallback
        return generateFirstRank();
      }
    }

    // If right is invalid or causes error, try with null (end)
    if (rightKey) {
      try {
        // Try inserting at end (after left)
        if (leftKey) {
          return generateKeyBetween(leftKey, null);
        }
      } catch {
        // Final fallback
        return generateFirstRank();
      }
    }

    // Final fallback to first rank
    return generateFirstRank();
  }
}
